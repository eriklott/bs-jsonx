// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var $$Map = require("bs-platform/lib/js/map.js");
var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Printf = require("bs-platform/lib/js/printf.js");
var $$String = require("bs-platform/lib/js/string.js");
var Js_dict = require("bs-platform/lib/js/js_dict.js");
var Js_json = require("bs-platform/lib/js/js_json.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_float = require("bs-platform/lib/js/caml_float.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var Dict = $$Map.Make([$$String.compare]);

function is_int(v) {
  var c = Caml_float.caml_classify_float(Caml_float.caml_modf_float(v)[0]);
  return +(c === /* FP_zero */2);
}

function decode_string(decode, json_str) {
  try {
    var json = JSON.parse(json_str);
    try {
      return /* Ok */Block.__(0, [Curry._1(decode, json)]);
    }
    catch (raw_exn){
      var exn = Js_exn.internalToOCamlException(raw_exn);
      if (exn[0] === Caml_builtin_exceptions.failure) {
        return /* Error */Block.__(1, [exn[1]]);
      } else {
        throw exn;
      }
    }
  }
  catch (exn$1){
    return /* Error */Block.__(1, [Curry._1(Printf.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "failed to decode json string: ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* End_of_format */0
                              ])
                          ]),
                        "failed to decode json string: %s"
                      ]), json_str)]);
  }
}

function string(json) {
  var match = Js_json.classify(json);
  var exit = 0;
  if (typeof match === "number" || match.tag) {
    exit = 1;
  } else {
    return match[0];
  }
  if (exit === 1) {
    return Pervasives.failwith(Curry._1(Printf.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "failed to decode json as string: ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* End_of_format */0
                              ])
                          ]),
                        "failed to decode json as string: %s"
                      ]), JSON.stringify(json)));
  }
  
}

function bool(json) {
  var match = Js_json.classify(json);
  var exit = 0;
  if (typeof match === "number") {
    switch (match) {
      case 0 : 
          return /* false */0;
      case 1 : 
          return /* true */1;
      case 2 : 
          exit = 1;
          break;
      
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    return Pervasives.failwith(Curry._1(Printf.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "failed to decode json as bool: ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* End_of_format */0
                              ])
                          ]),
                        "failed to decode json as bool: %s"
                      ]), JSON.stringify(json)));
  }
  
}

function $$int(json) {
  var fail = function () {
    return Pervasives.failwith(Curry._1(Printf.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "failed to decode json as int: ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* End_of_format */0
                              ])
                          ]),
                        "failed to decode json as int: %s"
                      ]), JSON.stringify(json)));
  };
  var match = Js_json.classify(json);
  if (typeof match === "number" || match.tag !== 1) {
    return fail(/* () */0);
  } else {
    var f = match[0];
    if (is_int(f)) {
      return f | 0;
    } else {
      return fail(/* () */0);
    }
  }
}

function $$float(json) {
  var match = Js_json.classify(json);
  var exit = 0;
  if (typeof match === "number" || match.tag !== 1) {
    exit = 1;
  } else {
    return match[0];
  }
  if (exit === 1) {
    return Pervasives.failwith(Curry._1(Printf.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "failed to decode json as float: ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* End_of_format */0
                              ])
                          ]),
                        "failed to decode json as float: %s"
                      ]), JSON.stringify(json)));
  }
  
}

function $$null(value, json) {
  var match = Js_json.classify(json);
  var exit = 0;
  if (typeof match === "number" && match >= 2) {
    return value;
  } else {
    exit = 1;
  }
  if (exit === 1) {
    return Pervasives.failwith(Curry._1(Printf.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "failed to decode json as null: ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* End_of_format */0
                              ])
                          ]),
                        "failed to decode json as null: %s"
                      ]), JSON.stringify(json)));
  }
  
}

function optional(decoder, json) {
  try {
    return /* Some */[Curry._1(decoder, json)];
  }
  catch (exn){
    return /* None */0;
  }
}

function one_of(decoders, json) {
  var _ds = decoders;
  while(true) {
    var ds = _ds;
    if (ds) {
      try {
        return Curry._1(ds[0], json);
      }
      catch (exn){
        _ds = ds[1];
        continue ;
        
      }
    } else {
      return Pervasives.failwith(Curry._1(Printf.sprintf(/* Format */[
                          /* String_literal */Block.__(11, [
                              "failed to decode json using any one of the provided decoders: ",
                              /* String */Block.__(2, [
                                  /* No_padding */0,
                                  /* End_of_format */0
                                ])
                            ]),
                          "failed to decode json using any one of the provided decoders: %s"
                        ]), JSON.stringify(json)));
    }
  };
}

function map(mapper, decoder, json) {
  return Curry._1(mapper, Curry._1(decoder, json));
}

function map2(mapper, d1, d2, json) {
  var v1 = Curry._1(d1, json);
  var v2 = Curry._1(d2, json);
  return Curry._2(mapper, v1, v2);
}

function map3(mapper, d1, d2, d3, json) {
  var v1 = Curry._1(d1, json);
  var v2 = Curry._1(d2, json);
  var v3 = Curry._1(d3, json);
  return Curry._3(mapper, v1, v2, v3);
}

function map4(mapper, d1, d2, d3, d4, json) {
  var v1 = Curry._1(d1, json);
  var v2 = Curry._1(d2, json);
  var v3 = Curry._1(d3, json);
  var v4 = Curry._1(d4, json);
  return Curry._4(mapper, v1, v2, v3, v4);
}

function map5(mapper, d1, d2, d3, d4, d5, json) {
  var v1 = Curry._1(d1, json);
  var v2 = Curry._1(d2, json);
  var v3 = Curry._1(d3, json);
  var v4 = Curry._1(d4, json);
  var v5 = Curry._1(d5, json);
  return Curry._5(mapper, v1, v2, v3, v4, v5);
}

function map6(mapper, d1, d2, d3, d4, d5, d6, json) {
  var v1 = Curry._1(d1, json);
  var v2 = Curry._1(d2, json);
  var v3 = Curry._1(d3, json);
  var v4 = Curry._1(d4, json);
  var v5 = Curry._1(d5, json);
  var v6 = Curry._1(d6, json);
  return Curry._6(mapper, v1, v2, v3, v4, v5, v6);
}

function map7(mapper, d1, d2, d3, d4, d5, d6, d7, json) {
  var v1 = Curry._1(d1, json);
  var v2 = Curry._1(d2, json);
  var v3 = Curry._1(d3, json);
  var v4 = Curry._1(d4, json);
  var v5 = Curry._1(d5, json);
  var v6 = Curry._1(d6, json);
  var v7 = Curry._1(d7, json);
  return Curry._7(mapper, v1, v2, v3, v4, v5, v6, v7);
}

function map8(mapper, d1, d2, d3, d4, d5, d6, d7, d8, json) {
  var v1 = Curry._1(d1, json);
  var v2 = Curry._1(d2, json);
  var v3 = Curry._1(d3, json);
  var v4 = Curry._1(d4, json);
  var v5 = Curry._1(d5, json);
  var v6 = Curry._1(d6, json);
  var v7 = Curry._1(d7, json);
  var v8 = Curry._1(d8, json);
  return Curry._8(mapper, v1, v2, v3, v4, v5, v6, v7, v8);
}

function nullable(decoder, state) {
  try {
    return $$null(/* None */0, state);
  }
  catch (exn){
    return /* Some */[Curry._1(decoder, state)];
  }
}

function list(decoder, json) {
  var match = Js_json.classify(json);
  var exit = 0;
  if (typeof match === "number" || match.tag !== 3) {
    exit = 1;
  } else {
    return List.map(decoder, $$Array.to_list(match[0]));
  }
  if (exit === 1) {
    return Pervasives.failwith(Curry._1(Printf.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "failed to decode json as a list: ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* End_of_format */0
                              ])
                          ]),
                        "failed to decode json as a list: %s"
                      ]), JSON.stringify(json)));
  }
  
}

function array(decoder, json) {
  var match = Js_json.classify(json);
  var exit = 0;
  if (typeof match === "number" || match.tag !== 3) {
    exit = 1;
  } else {
    return $$Array.map(decoder, match[0]);
  }
  if (exit === 1) {
    return Pervasives.failwith(Curry._1(Printf.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "failed to decode json as an array: ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* End_of_format */0
                              ])
                          ]),
                        "failed to decode json as an array: %s"
                      ]), JSON.stringify(json)));
  }
  
}

function dict(decoder, json) {
  var match = Js_json.classify(json);
  var exit = 0;
  if (typeof match === "number" || match.tag !== 2) {
    exit = 1;
  } else {
    return $$Array.fold_left((function (m, param) {
                  return Curry._3(Dict[/* add */3], param[0], Curry._1(decoder, param[1]), m);
                }), Dict[/* empty */0], Js_dict.entries(match[0]));
  }
  if (exit === 1) {
    return Pervasives.failwith(Curry._1(Printf.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "failed to decode json as a dict: ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* End_of_format */0
                              ])
                          ]),
                        "failed to decode json as a dict: %s"
                      ]), JSON.stringify(json)));
  }
  
}

function key_value_pairs(decoder, json) {
  var match = Js_json.classify(json);
  var exit = 0;
  if (typeof match === "number" || match.tag !== 2) {
    exit = 1;
  } else {
    return List.map((function (param) {
                  return /* tuple */[
                          param[0],
                          Curry._1(decoder, param[1])
                        ];
                }), $$Array.to_list(Js_dict.entries(match[0])));
  }
  if (exit === 1) {
    return Pervasives.failwith(Curry._1(Printf.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "failed to decode json as key value pairs: ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* End_of_format */0
                              ])
                          ]),
                        "failed to decode json as key value pairs: %s"
                      ]), JSON.stringify(json)));
  }
  
}

function field(k, decoder, json) {
  var fail = function () {
    return Pervasives.failwith(Curry._2(Printf.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "failed to decode json field '",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* String_literal */Block.__(11, [
                                    "': ",
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* End_of_format */0
                                      ])
                                  ])
                              ])
                          ]),
                        "failed to decode json field '%s': %s"
                      ]), k, JSON.stringify(json)));
  };
  var match = Js_json.classify(json);
  if (typeof match === "number" || match.tag !== 2) {
    return fail(/* () */0);
  } else {
    var match$1 = match[0][k];
    if (match$1 !== undefined) {
      return Curry._1(decoder, match$1);
    } else {
      return fail(/* () */0);
    }
  }
}

function at(fields, decoder) {
  return List.fold_right(field, fields, decoder);
}

function index(idx, decoder, json) {
  var fail = function () {
    return Pervasives.failwith(Curry._2(Printf.sprintf(/* Format */[
                        /* String_literal */Block.__(11, [
                            "failed to decode json at index '",
                            /* Int */Block.__(4, [
                                /* Int_d */0,
                                /* No_padding */0,
                                /* No_precision */0,
                                /* String_literal */Block.__(11, [
                                    "': ",
                                    /* String */Block.__(2, [
                                        /* No_padding */0,
                                        /* End_of_format */0
                                      ])
                                  ])
                              ])
                          ]),
                        "failed to decode json at index '%d': %s"
                      ]), idx, JSON.stringify(json)));
  };
  var match = Js_json.classify(json);
  if (typeof match === "number" || match.tag !== 3) {
    return fail(/* () */0);
  } else {
    var tmp;
    try {
      tmp = Caml_array.caml_array_get(match[0], idx);
    }
    catch (exn){
      tmp = fail(/* () */0);
    }
    return Curry._1(decoder, tmp);
  }
}

function succeed(value, _) {
  return value;
}

function fail(msg, _) {
  return Pervasives.failwith(msg);
}

function and_then(to_decoder, decoder, json) {
  var value = Curry._1(decoder, json);
  var decoder2 = Curry._1(to_decoder, value);
  return Curry._1(decoder2, json);
}

function and_map(d1, d2) {
  return (function (param) {
      return and_then((function (f) {
                    return (function (param) {
                        return Curry._1(f, Curry._1(d1, param));
                      });
                  }), d2, param);
    });
}

var $pipe$colon = and_map;

exports.Dict = Dict;
exports.decode_string = decode_string;
exports.string = string;
exports.bool = bool;
exports.$$int = $$int;
exports.$$float = $$float;
exports.$$null = $$null;
exports.nullable = nullable;
exports.list = list;
exports.array = array;
exports.dict = dict;
exports.key_value_pairs = key_value_pairs;
exports.field = field;
exports.at = at;
exports.index = index;
exports.optional = optional;
exports.one_of = one_of;
exports.map = map;
exports.map2 = map2;
exports.map3 = map3;
exports.map4 = map4;
exports.map5 = map5;
exports.map6 = map6;
exports.map7 = map7;
exports.map8 = map8;
exports.succeed = succeed;
exports.fail = fail;
exports.and_then = and_then;
exports.and_map = and_map;
exports.$pipe$colon = $pipe$colon;
/* Dict Not a pure module */
